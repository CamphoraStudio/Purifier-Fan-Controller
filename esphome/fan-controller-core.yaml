substitutions:
  fan_offset_step: "0.01f" # Stagger each fan speed by 1% (0.01)

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

json: # parse json messages over espnow


# Turns on the 12V fan power rail at boot and keeps it on.
switch:
  - platform: gpio
    pin: GPIO18
    id: enable_12v
    name: "12V Rail"
    internal: false
    restore_mode: ALWAYS_ON

globals:
  - id: received_voc_index
    type: int
    initial_value: '0'
  - id: received_nox_index
    type: int
    initial_value: '0'
  - id: operating_mode
    type: int
    initial_value: '0' # 0=Auto-Responsive, 1=Manual Override

text_sensor:
  - platform: template
    name: "Operating Mode"
    id: operating_mode_text
    lambda: |-
      if (id(operating_mode) == 1) {
        return {"Manual Override (Temporary)"};
      }
      return {"Auto-Responsive"};

button:
  - platform: template
    name: "Toggle Manual Override"
    id: toggle_manual_override_button
    icon: "mdi:hand-wave"
    on_press:
      - script.execute: toggle_manual_override

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true
    id: boot_button 
    internal: true
    filters:
      - delayed_on: 20ms

    # Action 1: When the button is FIRST pressed down.
    on_press:
      # Start the 10-second countdown for the factory reset.
      - script.execute: factory_reset_timer

    # Action 2: When the button is RELEASED.
    on_release:
      # Cancel the factory reset countdown.
      - script.stop: factory_reset_timer

    # Action 3: If the press-and-release cycle was SHORT (a "click").
    on_click:
      # We define a "short click" as anything under 2 seconds.
      max_length: 2s
      then:
        - logger.log: "SHORT CLICK: Pairing mode triggered."
        # Placeholder for pairing logic.

sensor:
  # Internal sensor to read the raw potentiometer voltage.
  - platform: adc
    pin: GPIO0
    id: raw_potentiometer_voltage
    attenuation: auto
    internal: true
    update_interval: 250ms
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1
      - delta: 0.01
    on_value:
      then:
        - lambda: |-
            const float OFF_ZONE_VOLTAGE = 0.1f;
            const float GUARD_BAND_VOLTAGE = 2.75f;
            float knob_position_level = 0.0f;

            if (x < OFF_ZONE_VOLTAGE) {
              knob_position_level = 0.0f;
            } else if (x > GUARD_BAND_VOLTAGE) {
              knob_position_level = 1.0f;
            } else {
              knob_position_level = (x - OFF_ZONE_VOLTAGE) / (GUARD_BAND_VOLTAGE - OFF_ZONE_VOLTAGE);
            }
            id(knob_position).publish_state(knob_position_level * 100.0);

  # Exposed sensor for the physical knob's position.
  - platform: template
    name: "Knob Position"
    id: knob_position
    unit_of_measurement: "%"
    icon: "mdi:knob"
    accuracy_decimals: 1
    on_value:
      then:
        - script.execute: recalculate_fan_speed

  # Exposed sensor for the final, authoritative fan speed target.
  - platform: template
    name: "Final Target Speed"
    id: final_target_speed
    unit_of_measurement: "%"
    icon: "mdi:fan-chevron-up"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            float target_speed_level = x / 100.0f;
            
            if (target_speed_level == 0.0f) {
              id(pwm_fan_1).set_level(0.0f);
              id(pwm_fan_2).set_level(0.0f);
              id(pwm_fan_3).set_level(0.0f);
              id(pwm_fan_4).set_level(0.0f);
              id(pwm_fan_5).set_level(0.0f);
            } else {
              auto calculate_pwm = [&](float speed) {
                return 0.1f + (speed * 0.9f);
              };
              
              float fan_1_target = target_speed_level;
              float fan_2_target = clamp(target_speed_level - (1 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_3_target = clamp(target_speed_level - (2 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_4_target = clamp(target_speed_level - (3 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_5_target = clamp(target_speed_level - (4 * ${fan_offset_step}), 0.0f, 1.0f);

              id(pwm_fan_1).set_level(calculate_pwm(fan_1_target));
              id(pwm_fan_2).set_level(calculate_pwm(fan_2_target));
              id(pwm_fan_3).set_level(calculate_pwm(fan_3_target));
              id(pwm_fan_4).set_level(calculate_pwm(fan_4_target));
              id(pwm_fan_5).set_level(calculate_pwm(fan_5_target));
            }

  # Tachometer Sensor with corrected RPM calculation.
  - platform: pulse_counter
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
    name: "Fan RPM"
    id: fan_rpm
    update_interval: 2s
    filters:
      - multiply: 0.5 # Convert Pulses/Min to Revolutions/Min (2 pulses per revolution)
    unit_of_measurement: "RPM"
    icon: "mdi:fan-clock"
    accuracy_decimals: 0

# Define all 5 PWM fan outputs.
output:
  - platform: ledc
    pin: GPIO3
    id: pwm_fan_1
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO4
    id: pwm_fan_2
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO5
    id: pwm_fan_3
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO6
    id: pwm_fan_4
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO7
    id: pwm_fan_5
    frequency: 25000 Hz

espnow:
  on_unknown_peer:
    - lambda: |-
        auto body = std::string(reinterpret_cast<const char*>(data), size);

        json::parse_json(body, [](JsonObject root) -> bool {
          if (!root["msg_type"].is<const char*>() || root["msg_type"] != "DATA") {
            return false;
          }
          if (!root["voc_index"].is<int>() || !root["nox_index"].is<int>()) {
            ESP_LOGE("espnow_parse", "JSON is missing or has malformed voc/nox indices.");
            return false;
          }

          int voc = root["voc_index"];
          int nox = root["nox_index"];

          ESP_LOGI("espnow_receive", "Received DATA: VOC=%d, NOx=%d", voc, nox);
          
          id(received_voc_index) = voc;
          id(received_nox_index) = nox;
          
          return true;
        });
    - script.execute: recalculate_fan_speed


script:
  - id: toggle_manual_override
    mode: single
    then:
      # Check the current mode and toggle it.
      - if:
          condition:
            lambda: 'return id(operating_mode) == 0;'
          # If in AUTO, switch to MANUAL
          then:
            - lambda: |-
                ESP_LOGI("mode_switch", "Entering Manual Override for 1 hour.");
                id(operating_mode) = 1;
                id(operating_mode_text).publish_state("Manual Override (Temporary)");
            - script.execute: manual_override_timer
          # If in MANUAL, switch back to AUTO
          else:
            - lambda: |-
                ESP_LOGI("mode_switch", "Reverting to Auto-Responsive mode.");
                id(operating_mode) = 0;
                id(operating_mode_text).publish_state("Auto-Responsive");
            - script.stop: manual_override_timer
      # Always recalculate the speed after a mode change.
      - script.execute: recalculate_fan_speed

  - id: manual_override_timer
    mode: single # Use 'single' so it can be stopped.
    then:
      - delay: 1h
      - lambda: |-
          ESP_LOGI("mode_switch", "Manual override expired. Reverting to Auto-Responsive mode.");
          id(operating_mode) = 0;
          id(operating_mode_text).publish_state("Auto-Responsive");
      - script.execute: recalculate_fan_speed

  - id: recalculate_fan_speed
    mode: single
    then:
      - lambda: |-
          float final_speed_level = 0.0f;
          float knob_percent = id(knob_position).state / 100.0f;

          // SPEC 3.4.1: If knob is at 0%, fan is always OFF.
          if (knob_percent == 0.0f) {
            id(final_target_speed).publish_state(0.0f);
            ESP_LOGD("auto_speed", "Knob is at 0%. Fan OFF.");
            return;
          }

          // Check if in Manual Override mode
          if (id(operating_mode) == 1) {
            final_speed_level = knob_percent;
            ESP_LOGD("auto_speed", "Manual Override Active. Speed set to Knob: %.0f%%", knob_percent * 100.0f);
          } else { // Otherwise, run the full Auto-Responsive logic.
            int voc = id(received_voc_index);
            int nox = id(received_nox_index);

            int voc_level = 0;
            if (voc >= 400) voc_level = 3; else if (voc >= 250) voc_level = 2; else if (voc >= 150) voc_level = 1;
            int nox_level = 0;
            if (nox >= 300) nox_level = 3; else if (nox >= 150) nox_level = 2; else if (nox >= 20) nox_level = 1;

            int worst_level = std::max(voc_level, nox_level);

            float boost_percentage = 0.0f;
            if (worst_level == 1) boost_percentage = 0.33f; else if (worst_level == 2) boost_percentage = 0.66f; else if (worst_level == 3) boost_percentage = 1.00f;

            final_speed_level = knob_percent + ((1.0f - knob_percent) * boost_percentage);
            ESP_LOGD("auto_speed", "Auto Mode. Knob:%.0f%%, Boost:%.0f%% -> Final:%.0f%%",
                     knob_percent * 100.0f, boost_percentage * 100.0f, final_speed_level * 100.0f);
          }
          
          id(final_target_speed).publish_state(final_speed_level * 100.0f);

  - id: factory_reset_timer
    mode: restart # 'restart' allows it to be started and stopped reliably.
    then:
      - delay: 10s
      # If the script reaches this point, the button has been held for 10s.
      - logger.log: "HOLD DETECTED: Factory reset initiated."
      # Placeholder for actual factory reset logic (e.g., changing LED color)


