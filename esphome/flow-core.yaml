# flow-core.yaml
# Main firmware for the Camphora Flow Air Purifier Fan Controller
# Handles all physical I/O and fan speed calculation.

substitutions:
   # Stagger each fan speed by 1% (0.01) to avoid resonance. Set to 0.0f to run all fans at the same speed.
  fan_offset_step: "0.01f"

packages:
  # Import all espnow communication-related logic from the separate file.
  comms: !include flow-esp-now.yaml

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf   # I had issues with arduino here, made the chip unupdatable

# --- Core Hardware & State ---
switch:
  # this one will be gone on hardware V2
  - platform: gpio
    pin: GPIO18
    id: enable_12v
    name: "12V Rail"
    internal: true
    restore_mode: ALWAYS_ON

globals:
  - id: received_voc_index
    type: int
    initial_value: '0'
  - id: received_nox_index
    type: int
    initial_value: '0'
  - id: operating_mode
    type: int
    initial_value: '0' # 0=Auto-Responsive, 1=Manual Override

# --- Physical User Interface ---
binary_sensor:
  # the boot button to flash, also used as the paring/factory reset button
  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true
    name: "Setup Button"
    filters:
      - delayed_on: 20ms
    # When the button is FIRST pressed down, start factory reset countdwon
    on_press:
      - script.execute: factory_reset_timer
    # When the button is RELEASED, stop factory reset countdown, if < time limit, factory reset won't happen
    on_release:
      - script.stop: factory_reset_timer
    # If the press release is quick, it's a short press, so enter pairing mode
    on_click:
      max_length: 2s
      then:
        # This script is defined in the comms package.
        - script.execute: enter_pairing_mode

text_sensor:
  - platform: template
    name: "Operating Mode"
    id: operating_mode_text
    lambda: |-
      if (id(operating_mode) == 1) {
        return {"Manual Override (Temporary)"};
      }
      return {"Auto-Responsive"};

button:
  - platform: template
    name: "Toggle Manual Override"
    id: toggle_manual_override_button
    icon: "mdi:hand-wave"
    on_press:
      - script.execute: toggle_manual_override

sensor:
  # Internal sensor to read the raw potentiometer voltage.
  - platform: adc
    pin: GPIO0
    id: raw_potentiometer_voltage
    attenuation: auto
    internal: true
    update_interval: 250ms
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1
      - delta: 0.01
    on_value:
      then:
        - lambda: |-
            // Calibrates raw voltage to a clean 0-100% knob position.
            const float OFF_ZONE_VOLTAGE = 0.1f;
            const float GUARD_BAND_VOLTAGE = 2.75f;
            float knob_position_level = 0.0f;

            if (x < OFF_ZONE_VOLTAGE) {
              knob_position_level = 0.0f;
            } else if (x > GUARD_BAND_VOLTAGE) {
              knob_position_level = 1.0f;
            } else {
              knob_position_level = (x - OFF_ZONE_VOLTAGE) / (GUARD_BAND_VOLTAGE - OFF_ZONE_VOLTAGE);
            }
            id(knob_position).publish_state(knob_position_level * 100.0);

  # Expose to HA for the physical knob's position, if knob changed, recalculate fan speed.
  - platform: template
    name: "Knob Position"
    id: knob_position
    unit_of_measurement: "%"
    icon: "mdi:knob"
    accuracy_decimals: 1
    on_value:
      then:
        - script.execute: recalculate_fan_speed

  # Exposed to HA for the final, authoritative fan speed target.
  - platform: template
    name: "Final Target Speed"
    id: final_target_speed
    unit_of_measurement: "%"
    icon: "mdi:fan-chevron-up"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            // Translate the final target speed (0-100%) into the five staggered PWM signals for the physical fans (10-100% duty cycle).
            // The minimum starts at 10% to ensure the fans can actually start spinning.
            float target_speed_level = x / 100.0f;
            
            if (target_speed_level == 0.0f) {
              id(pwm_fan_1).set_level(0.0f);
              id(pwm_fan_2).set_level(0.0f);
              id(pwm_fan_3).set_level(0.0f);
              id(pwm_fan_4).set_level(0.0f);
              id(pwm_fan_5).set_level(0.0f);
            } else {
              auto calculate_pwm = [&](float speed) {
                return 0.1f + (speed * 0.9f);
              };
              
              float fan_1_target = target_speed_level;
              float fan_2_target = clamp(target_speed_level - (1 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_3_target = clamp(target_speed_level - (2 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_4_target = clamp(target_speed_level - (3 * ${fan_offset_step}), 0.0f, 1.0f);
              float fan_5_target = clamp(target_speed_level - (4 * ${fan_offset_step}), 0.0f, 1.0f);

              id(pwm_fan_1).set_level(calculate_pwm(fan_1_target));
              id(pwm_fan_2).set_level(calculate_pwm(fan_2_target));
              id(pwm_fan_3).set_level(calculate_pwm(fan_3_target));
              id(pwm_fan_4).set_level(calculate_pwm(fan_4_target));
              id(pwm_fan_5).set_level(calculate_pwm(fan_5_target));
            }

  # Tachometer Sensor for reading fan RPM from one fan.
  - platform: pulse_counter
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
    name: "Fan RPM"
    id: fan_rpm
    update_interval: 2s
    filters:
      - multiply: 0.5 # Convert Pulses/Min to Revolutions/Min (2 pulses per revolution)
    unit_of_measurement: "RPM"
    icon: "mdi:fan-clock"
    accuracy_decimals: 0

# --- Fan PWM Outputs ---
output:
  - platform: ledc
    pin: GPIO3
    id: pwm_fan_1
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO4
    id: pwm_fan_2
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO5
    id: pwm_fan_3
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO6
    id: pwm_fan_4
    frequency: 25000 Hz
  - platform: ledc
    pin: GPIO7
    id: pwm_fan_5
    frequency: 25000 Hz

# --- Core Logic Scripts ---
script:
  - id: toggle_manual_override
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(operating_mode) == 0;' # If in AUTO
          then: # Switch to MANUAL
            - lambda: |-
                ESP_LOGI("mode_switch", "Entering Manual Override for 1 hour.");
                id(operating_mode) = 1;
                id(operating_mode_text).publish_state("Manual Override (Temporary)");
            - script.execute: manual_override_timer
          else: # If in MANUAL, switch back to AUTO
            - lambda: |-
                ESP_LOGI("mode_switch", "Reverting to Auto-Responsive mode.");
                id(operating_mode) = 0;
                id(operating_mode_text).publish_state("Auto-Responsive");
            - script.stop: manual_override_timer
      - script.execute: recalculate_fan_speed

  - id: manual_override_timer
    mode: single
    then:
      - delay: 1h
      - lambda: |-
          ESP_LOGI("mode_switch", "Manual override expired. Reverting to Auto-Responsive mode.");
          id(operating_mode) = 0;
          id(operating_mode_text).publish_state("Auto-Responsive");
      - script.execute: recalculate_fan_speed

  - id: recalculate_fan_speed
    mode: single
    then:
      - lambda: |-
          float final_speed_level = 0.0f;
          float knob_percent = id(knob_position).state / 100.0f;

          // Knob at 0% always means OFF.
          if (knob_percent == 0.0f) {
            id(final_target_speed).publish_state(0.0f);
            ESP_LOGD("auto_speed", "Knob is at 0%. Fan OFF.");
            return;
          }

          // In manual mode, speed equals knob position.
          if (id(operating_mode) == 1) {
            final_speed_level = knob_percent;
            ESP_LOGD("auto_speed", "Manual Override Active. Speed set to Knob: %.0f%%", knob_percent * 100.0f);
          } else { // In auto mode, calculate boost based on sensor data.
            int voc = id(received_voc_index);
            int nox = id(received_nox_index);

            // Determine pollution level (0-3) for VOC and NOx
            int voc_level = 0;
            if (voc >= 400) voc_level = 3; else if (voc >= 250) voc_level = 2; else if (voc >= 150) voc_level = 1;
            int nox_level = 0;
            if (nox >= 300) nox_level = 3; else if (nox >= 150) nox_level = 2; else if (nox >= 20) nox_level = 1;

            int worst_level = std::max(voc_level, nox_level);

            // Determine boost based on the worst pollution level
            float boost_percentage = 0.0f;
            if (worst_level == 1) boost_percentage = 0.33f;
            else if (worst_level == 2) boost_percentage = 0.66f;
            else if (worst_level == 3) boost_percentage = 1.00f;

            // Final speed = base speed + proportional boost of the remaining range
            final_speed_level = knob_percent + ((1.0f - knob_percent) * boost_percentage);
            ESP_LOGD("auto_speed", "Auto Mode. Knob:%.0f%%, Boost:%.0f%% -> Final:%.0f%%",
                     knob_percent * 100.0f, boost_percentage * 100.0f, final_speed_level * 100.0f);
          }
          
          id(final_target_speed).publish_state(final_speed_level * 100.0f);

  # ---- Factory Reset Logic ----
  - id: factory_reset_timer
    mode: restart
    then:
      - delay: 10s
      - logger.log: "HOLD DETECTED: Factory reset initiated."
      - script.execute: factory_reset

  - id: factory_reset
    mode: single
    then:
      # Step 1: Call the script in the comms package to clear pairing.
      - script.execute: clear_espnow_pairing
      # Step 2: Add other core device reset actions here (e.g., Wi-Fi).
      # - wifi.delete_sta_config:
      - logger.log: "CORE: Factory reset complete."